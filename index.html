<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/liuyujie714/chemjs/js/pmd.min.css">
        <script src="https://cdn.jsdelivr.net/gh/liuyujie714/chemjs/js/cpp/libgmxtpr.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/liuyujie714/chemjs/js/cpp/libgauchk.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/liuyujie714/chemjs/js/cpp/libsmiles2mol.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/liuyujie714/chemjs/js/cpp/libfindbonds.js"></script>

        <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/liuyujie714/chemjs/js/ChemDoodleWeb.js"></script>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/liuyujie714/chemjs/js/uis/jquery-ui-1.10.3.custom.css" type="text/css">
        <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/liuyujie714/chemjs/js/uis/ChemDoodleWeb-uis.js"></script>

        <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/liuyujie714/chemjs/js/jsmol/JSmol.min.js"></script>
        <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/liuyujie714/chemjs/js/jsmol/JSmolJME.js"></script>
        <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/liuyujie714/chemjs/js/jsmol/jsme/jsme/jsme.nocache.js"></script>
        <title>分子可视化</title>
    </head>
    
    <div class="wrap">

    <div style="position: fixed; left: 5px; top: 50px; width: 150px; font-size: 12px;">
        <div style="cursor: pointer; font-weight: bold;" onclick="toggleHelp()">
            Help ▶
        </div>

        <!-- 添加控制面板切换按钮 -->
        <div style="cursor: pointer; font-weight: bold; margin-top: 10px;" onclick="toggleControlPanel()">
            Bend ▶
        </div>
        <div id="help" style="margin-top: 0.5rem; display: none;">
            电脑端:<br>
            Ctrl+Z: 撤销绘制操作<br>
            鼠标左键: 旋转分子<br>
            Alt+鼠标左键: 移动分子<br>
            鼠标滚轮: 缩放分子<br>
            <br>
            手机端:<br>
            单指拖动：旋转分子<br>
            双指拖动：移动分子<br>
            双指缩放：缩放分子<br>
            <br>
            注意当从外部读取文件可视化时，整体原子坐标和盒子边界会自动平移，因此和源文件坐标不一致，但这<b>不影响分子可视化效果</b>。
            <br>
            原子成键除了tpr是来自力场本身定义，其他格式都是基于距离搜索进行判定的，大体系下pdb，xyz，gro格式读取速度最快，因为该部分基于C++代码。
            <br>
            chg和tpr文件支持原子电荷的读取
        </div>

        <script>
            function toggleHelp() {
                const content = document.getElementById('help');
                const arrow = document.querySelector('div[onclick="toggleHelp()"]');
                
                if (content.style.display === 'none') {
                    content.style.display = 'block';
                    arrow.innerHTML = 'Help ▼';
                } else {
                    content.style.display = 'none';
                    arrow.innerHTML = 'Help ▶';
                }
            }

            function toggleControlPanel() {
                const panelCell = document.querySelector('tr:first-child td:nth-child(3)');
                const panelRow = document.querySelector('tr:nth-child(2) td:nth-child(3)');
                const button = document.querySelector('div[onclick="toggleControlPanel()"]');
                if (panelCell.style.display === 'none') {
                    // 显示控制面板
                    panelCell.style.display = '';
                    panelRow.style.display = '';
                    button.innerHTML = 'Bend ▼';
                } else {
                    // 隐藏控制面板
                    panelCell.style.display = 'none';
                    panelRow.style.display = 'none';
                    button.innerHTML = 'Bend ▶';
                }
            }
        </script>
    </div>
    
    <table>
        <tr>
            <td>
                <div style="display: flex;">
                    <input type="file" id="loadfile" value="读取文件" accept=".pdb, .mol, .cml, .chg, .xyz, .gro, .tpr, .chk" style="font-size:1em;font-weight:bold;color:red;width:200px; height:30px" />
                    <input type="text" id="inputsmiles" style="font-size:1em;font-weight:normal;color:black;width:200px; height:20px"/>
                </div>
                <script>
                    var $ = function(id) { return document.getElementById(id); }
                    
                    $("inputsmiles").addEventListener("keydown", async function(e) {
                        if (e.keyCode == 13) {
                            e.preventDefault();
                            const value = this.value.trim();
                            if (value) {
                                await molFromSmiles(value);
                            }
                        }
                    })
                </script>
            </td>
            <td>
                <div style="display: flex;">
                    <input type="button" id="import3d" onclick="molFromSketch()" value="=>从画板导入3D分子" style="font-size:1em;font-weight:bold;color:red;width:50%; height:30px;margin-right: 20px;" />
                    <input type="button" id="savefile" onclick="savefile()" value="导出3D分子" style="font-size:1em;font-weight:bold;color:red;width:50%; height:30px" />
                </div>
            </td>

            <td style="text-align: center; vertical-align: middle;display: none;">
                <span style="font-size:1em; font-weight:bold; color:red; cursor:pointer;">
                    分子弯曲控制(Test)
                </span>
            </td>
                    
        </tr>

        <tr>
            <td>
                <div id="jmediv" style="position:relative;width:400px;height:500px;"></div>
                <script>
                    // 创建一个分子画板
                    var jme = "jme";
                    let JMEInfo = {     
                        use: "HTML5",
                        divId: "jmediv", 
                        options : "autoez;nocanonize;",
                        editOptions: "editDisabled;",
                    };
                    Jmol.getJMEApplet("jme", JMEInfo);
                </script>
            </td>

            <td>
                <script>
                    // global atom altLabel(lab+serial) to index(0-based)
                    var g_lab2ids = new Map();

                    // add atom serial (1-based) from mol
                    function addAtomSerial(mol) {
                        g_lab2ids.clear()
                        for (let i = 0; i < mol.atoms.length; i++) {
                            let newlab = mol.atoms[i].label+String(i+1);
                            mol.atoms[i].altLabel = newlab; // display atom text
                            g_lab2ids.set(newlab, i);
                        }
                    }

                    // set atom & bond resolution, input: number of atoms
                    function set_resolution(nat) { 
                        let res = 30;
                        if (nat<5000) {
                            res = 30;
                        } else if (nat<50000) {
                            res = 20;
                        } else if (nat<100000) {
                            res = 10;
                        } else {
                            res = 5;
                        }
                        Mol.specs.atoms_resolution_3D = res;
                        Mol.specs.bonds_resolution_3D = res;
                    }

                    // add atom serial and loadMolecule (without pbc) and set resolution
                    function loadMolNoPBC(mol) { 
                        g_basePositions = null;
                        set_resolution(mol.atoms.length);
                        addAtomSerial(mol)
                        Mol.loadMolecule(mol);
                    }

                    // add atom serial and loadContent (pbc) and set resolution
                    function loadMolPBC(obj) { 
                        g_basePositions = null;
                        set_resolution(obj.molecule.atoms.length);
                        addAtomSerial(obj.molecule);
                        Mol.loadContent([obj.molecule], [obj.unitCell]);
                    }

                    // 分子显示
                    var Mol = new ChemDoodle.EditorCanvas3D('Mol', 400, 450, {useServices:false, includeToolbar:true});
                    // 记录分子初始位置
                    var g_basePositions = null;
                    Mol.specs.backgroundColor='#000000';
                    Mol.specs.set3DRepresentation('Line');
                    Mol.specs.projectionPerspective_3D = true; // 透视投影
                    Mol.specs.compass_display=true; // 坐标轴显示
                    Mol.specs.atoms_displayLabels_3D=false; // 原子标签显示
                    Mol.specs.bonds_splitColor = true;
                    Mol.specs.text_font_stroke_3D = true;
                    Mol.specs.shapes_color = 'blue'; // such as box color
                    //Mol.specs.bonds_cylinderDiameter_3D = 0.3; //键粗细
                    // 动画设置
                    Mol.handle = null;
                    Mol.timeout = 15;
                    Mol.startAnimation = ChemDoodle._AnimatorCanvas.prototype.startAnimation;
                    Mol.stopAnimation = ChemDoodle._AnimatorCanvas.prototype.stopAnimation;
                    Mol.isRunning = ChemDoodle._AnimatorCanvas.prototype.isRunning;
                    Mol.dblclick = ChemDoodle.RotatorCanvas.prototype.dblclick;
                    Mol.nextFrame = function(delta){
                        let matrix = [];
                        ChemDoodle.lib.mat4.identity(matrix);
                        let change = delta*Math.PI/50000;
                        ChemDoodle.lib.mat4.rotate(matrix, change, [ 1, 0, 0 ]);
                        ChemDoodle.lib.mat4.rotate(matrix, change, [ 0, 1, 0 ]);
                        ChemDoodle.lib.mat4.rotate(matrix, change, [ 0, 0, 1 ]);
                        ChemDoodle.lib.mat4.multiply(this.rotationMatrix, matrix)
                    };
                    ChemDoodle.io.file.content('https://cdn.jsdelivr.net/gh/liuyujie714/chemjs/mol/C640.pdb', function(fileContent) {
                        let mol = ChemDoodle.readPDB(fileContent);
                        loadMolNoPBC(mol);
                    });
                    Mol.startAnimation(); // 开始动画

                    function alertMolecule() {
                        let message = 'This molecule contains ' + Mol.molecules[0].atoms.length + ' atoms and ' + Mol.molecules[0].bonds.length + ' bonds.';
                        alert(message);
                    }
        
                    function setview(id) {   
                        switch(id)
                        {
                            case 'Line':
                                Mol.specs.set3DRepresentation('Line');
                                break;
                            case 'Stick':
                                Mol.specs.set3DRepresentation('Stick');
                                break;
                            case 'Wireframe':
                                Mol.specs.set3DRepresentation('Wireframe');
                                break;
                            case 'vdW':
                                Mol.specs.set3DRepresentation('van der Waals Spheres');
                                break;
                            case 'CPK':
                                Mol.specs.set3DRepresentation('Ball and Stick');
                                break;
                        }
                        Mol.repaint();
                    }

                    // only work %s and %f
                    function sprintf() {
                        var a={s:function(a,b){return b*=1,m=Array(Math.max(Math.abs(b)-a.length+1,0)).join(" "),b>0?m+a:a+m},f:function(a,b){return b=b.split("."),a=parseFloat(a).toFixed(b[1]),m=Array(Math.max(Math.abs(b[0])-a.length+1,0)).join(" "),b[0]>0?m+a:a+m}},b=Array.prototype.slice.call(arguments).slice();return b.shift().toString().replace(/%(-*\d*\.*\d*)([sf])/g,function(c,d,e){if(!b.length)throw new Error("Too few elements");return a[e](b.shift(),d)})
                    }
        
                    function getcoords() {
                       // 第一个分子
                       let atoms = Mol.molecules[0].atoms;
                       let s = atoms.length+"\nMOL\n";
                       atoms.forEach(e => {
                            s += sprintf("%5s", e.label)+sprintf("%12.6f", e.x)+sprintf("%12.6f", e.y)+sprintf("%12.6f", e.z)+"\n";
                       });
                       $("textarea").value = s;
                    }

                    // remove multi started spaces and add '\n'
                    function ltrim(s) {
                        return s.split('\n').map(line=>line.trimStart()).join('\n');
                    }

                    function setcoords() {
                        try {
                            let xyz = ChemDoodle.readXYZ(ltrim($("textarea").value));
                            Mol.loadMolecule(xyz);
                        }
                        catch (error) {
                            alert("坐标输入格式错误, 必须是XYZ");
                            return;
                        }
                    }

                    function setLabel(value) {
                        let status = false;
                        let mol = Mol.molecules[0];
                        let n = mol.atoms.length;
                        let ndigit = 4;
                        switch(value)
                        {
                            case 'None':
                                status = false;
                                break;
                            case 'E':
                                for (let i = 0; i < n; i++) {
                                    mol.atoms[i].altLabel = mol.atoms[i].label;
                                }
                                status = true;
                                break;
                            case 'N':
                                for (let i = 0; i < n; i++) {
                                    mol.atoms[i].altLabel = String(i+1);
                                }
                                status = true;
                                break;
                            case 'E_N':
                                for (let i = 0; i < n; i++) {
                                    mol.atoms[i].altLabel = mol.atoms[i].label+String(i+1);
                                }
                                status = true;
                                break;
                            case 'Q':
                                for (let i = 0; i < n; i++) {
                                    let chg = mol.atoms[i].charge;
                                    mol.atoms[i].altLabel = typeof chg == 'string' ? parseFloat(chg).toFixed(ndigit) : chg.toFixed(ndigit);
                                }
                                status = true;
                                break;
                            case 'E_Q':
                                for (let i = 0; i < n; i++) {
                                    let chg = mol.atoms[i].charge;
                                    let q = typeof chg == 'string' ? parseFloat(chg).toFixed(ndigit) : chg.toFixed(ndigit);
                                    mol.atoms[i].altLabel = mol.atoms[i].label+'('+q+')';
                                }
                                status = true;
                                break;
                        }
                        // set up atom label style
                        Mol.specs.atoms_displayLabels_3D=status;
                        Mol.setupScene()
                        Mol.repaint();

                        // restore altLabel because of write mol2 file is need
                        for (let i = 0; i < n; i++) {
                            mol.atoms[i].altLabel = mol.atoms[i].label+String(i+1);
                        }
                    }

                    // find 3-9 members rings from mol 
                    function findRings(mol) {
                        // fingerBreak = 5
                        return (new ChemDoodle.informatics.EulerFacetRingFinder(mol)).rings
                    }

                    function extension(t) {return t.substring(t.lastIndexOf(".")+1).toLowerCase()}

                    // convert the three triclinic box vectors to pdb cryst1
                    function triclinicToABC(lx, ly, lz, xy, xz, yz) {
                        const a = [lx, 0, 0];
                        const b = [xy, ly, 0];
                        const c = [xz, yz, lz];

                        const norm = v => Math.sqrt(v[0]**2 + v[1]**2 + v[2]**2);
                        const dot = (u, v) => u[0]*v[0] + u[1]*v[1] + u[2]*v[2];

                        const na = norm(a);
                        const nb = norm(b);
                        const nc = norm(c);

                        const alpha = Math.acos(dot(b, c) / (nb * nc)) * 180 / Math.PI;
                        const beta  = Math.acos(dot(a, c) / (na * nc)) * 180 / Math.PI;
                        const gamma = Math.acos(dot(a, b) / (na * nb)) * 180 / Math.PI;

                        return { a: na, b: nb, c: nc, alpha, beta, gamma };
                    }

                    // Convert [lx, ly, lz, alpha, beta, gamma] to a triclinic 3x3 matrix (flattened).
                    function ABCTotriclinic(dimensions) {
                        let [lx, ly, lz, alpha, beta, gamma] = dimensions.map(Number);
                        const zerobox = [0,0,0,0,0,0,0,0,0];

                        // Only positive edge lengths and angles in (0, 180) are allowed
                        if (!(lx > 0 && ly > 0 && lz > 0 &&
                            alpha > 0 && alpha < 180 &&
                            beta > 0 && beta < 180 &&
                            gamma > 0 && gamma < 180)) {
                            return zerobox;
                        }

                        // detect orthogonal boxes
                        if (alpha === 90 && beta === 90 && gamma === 90) {
                            return [
                                lx, 0, 0,
                                0, ly, 0,
                                0, 0, lz
                            ];
                        }

                        // general triclinic box
                        const deg2rad = d => d * Math.PI / 180;

                        let cosAlpha = (alpha === 90) ? 0 : Math.cos(deg2rad(alpha));
                        let cosBeta  = (beta  === 90) ? 0 : Math.cos(deg2rad(beta));
                        let cosGamma, sinGamma;
                        if (gamma === 90) {
                            cosGamma = 0;
                            sinGamma = 1;
                        } else {
                            const g = deg2rad(gamma);
                            cosGamma = Math.cos(g);
                            sinGamma = Math.sin(g);
                        }

                        const m = [
                            [lx, 0, 0],
                            [ly * cosGamma, ly * sinGamma, 0],
                            [0, 0, 0]
                        ];

                        m[2][0] = lz * cosBeta;
                        m[2][1] = lz * (cosAlpha - cosBeta * cosGamma) / sinGamma;
                        const z2 = lz * lz - m[2][0]**2 - m[2][1]**2;
                        m[2][2] = z2 > 0 ? Math.sqrt(z2) : 0;

                        return m[2][2] <= 0? zerobox : m.flat();
                    }


                    // convert cartesian to fractional
                    function fracCoords(x, y, z, a_vec, b_vec, c_vec) {
                        let M = [
                            [a_vec[0], b_vec[0], c_vec[0]],
                            [a_vec[1], b_vec[1], c_vec[1]],
                            [a_vec[2], b_vec[2], c_vec[2]]
                        ];

                        // 求逆
                        let det = M[0][0]*(M[1][1]*M[2][2]-M[1][2]*M[2][1])
                                - M[0][1]*(M[1][0]*M[2][2]-M[1][2]*M[2][0])
                                + M[0][2]*(M[1][0]*M[2][1]-M[1][1]*M[2][0]);

                        let inv = [
                            [
                            (M[1][1]*M[2][2]-M[1][2]*M[2][1])/det,
                            (M[0][2]*M[2][1]-M[0][1]*M[2][2])/det,
                            (M[0][1]*M[1][2]-M[0][2]*M[1][1])/det
                            ],
                            [
                            (M[1][2]*M[2][0]-M[1][0]*M[2][2])/det,
                            (M[0][0]*M[2][2]-M[0][2]*M[2][0])/det,
                            (M[0][2]*M[1][0]-M[0][0]*M[1][2])/det
                            ],
                            [
                            (M[1][0]*M[2][1]-M[1][1]*M[2][0])/det,
                            (M[0][1]*M[2][0]-M[0][0]*M[2][1])/det,
                            (M[0][0]*M[1][1]-M[0][1]*M[1][0])/det
                            ]
                        ];

                        // 乘以逆矩阵
                        let fx = inv[0][0]*x + inv[0][1]*y + inv[0][2]*z;
                        let fy = inv[1][0]*x + inv[1][1]*y + inv[1][2]*z;
                        let fz = inv[2][0]*x + inv[2][1]*y + inv[2][2]*z;

                        return [fx, fy, fz];
                    }

                    // 没有任何对称操作，只能针对有晶胞信息的体系，没有盒子大小的体系不可用cif
                    function cif_header(n, crystal) {
                        return "data_MOL\n" + "__chemical_name_mineral " + n + 
                        "\n_cell_length_a " + crystal.a + "\n_cell_length_b " +  crystal.b + "\n_cell_length_c " + crystal.c + 
                        "\n_cell_angle_alpha " + crystal.alpha +
                        "\n_cell_angle_beta " + crystal.beta + 
                        "\n_cell_angle_gamma " + crystal.gamma + 
                        "\n_symmetry_space_group_name_H-M 'P 1'" + "\nloop_\n_space_group_symop_operation_xyz\n'x, y, z'" +
                        "\nloop_\n_atom_site_label\n_atom_site_type_symbol\n_atom_site_fract_x\n_atom_site_fract_y\n_atom_site_fract_z\n";
                    }

                    // convert atomname to correct element name, trim start & end space, fix number
                    function fix_atomname(name) {
                        // exclude such as H111R
                        name = name.trim();
                        // trim started number
                        if((pos = name.search(/\d/))==0) {
                            name = name.substring(pos+1);
                        }
                        pos = name.search(/\d/);
                        if (pos != -1) {
                            name = name.substring(0, pos);
                        }
                        // H* -> H element
                        if (name.startsWith('H')) {
                            name = name[0];
                        }
                        // fix OW and HW
                        if (name.substring(0, 2).toUpperCase()=='HW' || 
                            name.substring(0, 2).toUpperCase()=='OW' || 
                            name.substring(0, 2).toUpperCase()=='OH') {
                            name = name[0];
                        }
                        // fix some special metal atom names
                        ['FE', 'ZN', 'CU', "CO", 'MG', 'AU', 'AG', 'AL', "SI", 'CL', "LI", "PT"].forEach(e => { 
                            if (name.startsWith(e)) {
                                name = name[0].toUpperCase() + (name.length>1? name[1].toLowerCase() : '');
                            }
                        })
                        // charmm ions
                        if (name.startsWith('POT')) {
                            name = 'K';
                        } else if (name.startsWith('SOD')) {
                            name = 'Na';
                        }
                        return name;
                    }

                    // read gromacs tpr and return names, positions, charges, box and bonds (unique)
                    async function readTpr(arrbuffer) {
                        let filename = "___temp.tpr";
                        const module = await TprModule();
                        let uint8View = new Uint8Array(arrbuffer);
                        module.FS.writeFile(filename, uint8View);
                        const tpr = new module.TprReader(filename, false, false, false);
                        const c = tpr.get_xvf("x"); // nm
                        const q = tpr.get_xvf("q"); // charge
                        const name = tpr.get_name('atom'); // atomname
                        const box =  tpr.get_xvf("box");
                        // 1-based index
                        const bonds = tpr.get_bonded('bonds');
                        tpr.delete();
                        module.FS.unlink(filename);
                        let ux = box.get(0)*10.0;
                        let uy = box.get(4)*10.0;
                        let uz = box.get(8)*10.0;
                        let xy = box.get(3)*10.0;
                        let xz = box.get(6)*10.0;
                        let yz = box.get(7)*10.0;
                        let natoms = c.size()/3;
                        let names = [], positions = [], charges = [];
                        let ispbc = (ux>0 && uy>0 && uz>0);
                        const cbox = ispbc? [ux, 0, 0, xy, uy, 0, xz, yz, uz] : [0,0,0,0,0,0,0,0,0];
                        for (let i = 0; i < natoms; i++) {
                                let x = c.get(3*i) * 10.0;
                                let y = c.get(3*i+1) * 10.0;
                                let z = c.get(3*i+2) * 10.0;
                                names.push(fix_atomname(name.get(i)));
                                positions.push(x, y, z);
                                // atom charge
                                charges.push(q.get(i));
                        }
                        // get bonds
                        let jsbonds = new Map();
                        for (let i = 0; i < bonds.size(); i++) {
                            // to 0-based index
                            const a = bonds.get(i).a-1;
                            const b = bonds.get(i).b-1;
                            const key = a < b ? a+"-"+b : b+"-"+a;
                            // remove duplicates
                            if (!jsbonds.has(key)) {
                                jsbonds.set(key, [a, b]);
                            }
                        }
                        return {names, positions, box:cbox, bonds:Array.from(jsbonds.values()), charges};
                    }

                    // convert gaussian binary chk file to cif & xyz text
                    async function readCHK(arrbuffer) {
                        let filename = "___temp.chk";
                        const module = await ChkModule();
                        let uint8View = new Uint8Array(arrbuffer);
                        module.FS.writeFile(filename, uint8View);
                        const chk = new module.GauChkParserWarpper(filename);
                        const name = chk.get_name(); // element names
                        const c = chk.get_coords(); // coorrds, 3*natoms
                        chk.delete();
                        module.FS.unlink(filename);
                        let natoms = c.size()/3;
                        // TODO: get unit cell
                        let ispbc = false; 
                        let cif = "";
                        let xyz = "";
                        if (ispbc) {
                            // TODO
                            let ux = 1, uy = 1, uz = 1, xy = 0, xz = 0, yz = 0;
                            let crystal = triclinicToABC(ux, uy, uz, xy, xz, yz);
                            cif = cif_header(natoms, crystal);
                            let a_vec = [ux, 0, 0];
                            let b_vec = [xy, uy, 0];
                            let c_vec = [xz, yz, uz];
                            for (let i = 0; i < natoms; i++) {
                                let x = c.get(3*i);
                                let y = c.get(3*i+1);
                                let z = c.get(3*i+2);
                                let [fx, fy, fz] = fracCoords(x, y, z, a_vec, b_vec, c_vec);
                                cif += sprintf("MOL %s %8.3f %8.3f %8.3f\n", name.get(i), fx, fy, fz);
                            }
                        } 
                        else {
                            xyz += natoms + "\nMOL\n";
                            for (let i = 0; i < natoms; i++) {
                                let x = c.get(3*i);
                                let y = c.get(3*i+1);
                                let z = c.get(3*i+2);
                                xyz += sprintf("%s %8.3f %8.3f %8.3f\n", name.get(i), x, y, z);
                            }
                        }
                        return {cif:cif, xyz:xyz, ispbc:ispbc};
                    }

                    // fast find atom bonds based distance, return Array(atom1, atom2, distance)
                    async function find_bonds(names, positions, box) {
                        const module = await FindBondsModule();
                        // use c++ vector
                        const cnames = new module.VecString();
                        const cpositions = new module.VecFloat();
                        const cbox = new module.VecFloat();
                        // copy data
                        names.forEach(name => cnames.push_back(name));
                        positions.forEach(pos => cpositions.push_back(pos));
                        box.forEach(f => cbox.push_back(f));
                        // convert result to js array
                        bonds = module.find_bonds(cnames, cpositions, cbox, true);
                        jsbonds = [];
                        for (let i=0; i<bonds.size(); i++) {
                            let bond = bonds.get(i);
                            jsbonds.push([bond.i, bond.j, bond.d]);
                        }
                        // free vector memory
                        cnames.delete();
                        cpositions.delete();
                        cbox.delete();
                        bonds.delete();

                        return jsbonds;
                    }

                    // A more efficient way to read the xyz file, ignoring bondorder
                    // box (9 float values) can be zero, represent no pbc
                    async function readXYZFast(names, positions, box, autobonds = true) {
                        // check input
                        if (names.length != positions.length/3) {
                            throw new Error("The number of atom names does not equal to the number of atom positions");
                        }
                        if (box.length != 9) {
                            throw new Error("The box size is not 9");
                        }

                        // convert xyz str
                        let xyzstr = names.length + '\nMOL\n';
                        for (let i = 0; i < names.length; i++) {
                            xyzstr += sprintf("%s %8.3f %8.3f %8.3f\n", names[i], positions[3*i], positions[3*i+1], positions[3*i+2]);
                        }

                        function XYZInterpreter() {}
                        XYZInterpreter.prototype = new ChemDoodle.io._Interpreter();
                        XYZInterpreter.prototype.deduceCovalentBonds = false;
                        XYZInterpreter.prototype.read = async function(a) {
                            const molecule = new ChemDoodle.structures.Molecule();
                            if (!a) return molecule;

                            const lines = a.split("\n");
                            const natoms = parseInt(ChemDoodle.lib.jQuery.trim(lines[0]));

                            for (let i = 0; i < natoms; i++) {
                                const tokens = lines[i + 2].trim().split(/\s+/g);
                                molecule.atoms[i] = new ChemDoodle.structures.Atom(
                                    isNaN(tokens[0]) ? tokens[0] : ChemDoodle.SYMBOLS[parseInt(tokens[0]) - 1],
                                    parseFloat(tokens[1]),
                                    parseFloat(tokens[2]),
                                    parseFloat(tokens[3])
                                );
                            }

                            //(new ChemDoodle.informatics.BondDeducer()).deduceCovalentBonds(molecule, 1);
                            if (autobonds) {
                                let bondorder = 1;
                                const bonds = await find_bonds(names, positions, box);
                                bonds.forEach(b=> {
                                    molecule.bonds.push(new ChemDoodle.structures.Bond(molecule.atoms[b[0]], molecule.atoms[b[1]], bondorder));
                                })
                            }

                            return molecule;
                        };

                        // 创建实例并调用 read 方法
                        const interpreter = new XYZInterpreter();
                        return interpreter.read(xyzstr);
                    }

                    // build cell from gmx box (1D, 9 values)
                    function build_cell_from_gmxbox(mol, box) {
                        const a = [box[0], box[1], box[2]];
                        const b = [box[3], box[4], box[5]];
                        const c = [box[6], box[7], box[8]];
                        const center = mol.getCenter3D(); // molecule center in Atom
                        const origin = [-center.x, -center.y,-center.z];
                        const o = origin;
                        const x   = [origin[0] + a[0], origin[1] + a[1], origin[2] + a[2]];
                        const y   = [origin[0] + b[0], origin[1] + b[1], origin[2] + b[2]];
                        const z   = [origin[0] + c[0], origin[1] + c[1], origin[2] + c[2]];
                        const xyv = [origin[0] + a[0]+b[0], origin[1] + a[1]+b[1], origin[2] + a[2]+b[2]];
                        const xzv = [origin[0] + a[0]+c[0], origin[1] + a[1]+c[1], origin[2] + a[2]+c[2]];
                        const yzv = [origin[0] + b[0]+c[0], origin[1] + b[1]+c[1], origin[2] + b[2]+c[2]];
                        const xyz = [origin[0] + a[0]+b[0]+c[0], origin[1] + a[1]+b[1]+c[1], origin[2] + a[2]+b[2]+c[2]];
                        return new ChemDoodle.structures.d3.UnitCell({o, x, y, z, xy: xyv, xz: xzv, yz: yzv, xyz});
                    }

                    function loadfile(t) {
                        let a=t.target.files[0];
                        if(a) {
                            // 停止动画
                            Mol.stopAnimation();
                            set_resolution(0); // keep good resolution

                            let r=new FileReader;
                            let s = extension(a.name);

                            r.onload=function(t) {
                                content=t.target.result;
                                let obj;
                                let names = [], positions = [], natoms = 0, lines, b;
                                const zerobox = [0,0,0,0,0,0,0,0,0];
                                switch(s)
                                {
                                    case 'pdb':
                                        // obj = ChemDoodle.readPDB(content); // the method is not work for non-standard pdb file
                                        let pdbcell;
                                        content.split('\n').forEach(function (line) {
                                            if (line.startsWith("ATOM") || line.startsWith("HETATM")) {
                                                // must remove number in str
                                                name = fix_atomname(line.substring(12, 16));
                                                let x = parseFloat(line.substring(30, 38));
                                                let y = parseFloat(line.substring(38, 46));
                                                let z = parseFloat(line.substring(46, 54));

                                                names.push(name);
                                                positions.push(x, y, z);
                                            } else if (line.startsWith("CRYST1")) {
                                                let data = line.split(/\s+/g);
                                                pdbcell = [parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]), 
                                                          parseFloat(data[4]), parseFloat(data[5]), parseFloat(data[6])];
                                            }
                                        })
                                        b = pdbcell==undefined? zerobox : ABCTotriclinic(pdbcell);
                                        readXYZFast(names, positions, b, true).then(mol => {
                                            const cell = build_cell_from_gmxbox(mol, b);
                                            loadMolPBC({molecule:mol, unitCell:cell});
                                            alertMolecule();
                                        });
                                        break;
                                    case 'xyz':
                                        lines = content.split('\n');
                                        natoms = parseInt(lines[0]);
                                        for (let i = 0; i < natoms; i++) {
                                            line = lines[i+2].trim().split(/\s+/g);
                                            names.push(fix_atomname(line[0]));
                                            positions.push(parseFloat(line[1]), parseFloat(line[2]), parseFloat(line[3]));
                                        }
                                        readXYZFast(names, positions, zerobox, true).then(mol => { 
                                            loadMolNoPBC(mol);
                                            alertMolecule();
                                        });
                                        break;
                                    case 'mol':
                                        obj = ChemDoodle.readMOL(content, 1);
                                        loadMolNoPBC(obj);
                                        alertMolecule();
                                        break;
                                    case 'cml':
                                        // fix non-standard CML, molecule must between <cml> and </cml>
                                        let hascml = (content.lastIndexOf('</cml>')!=-1);
                                        if (!hascml) {
                                            if (content.indexOf('<molecule')!=-1 && content.indexOf('</molecule>')!=-1) {
                                                content = content.replace('<molecule', '<cml>\n<molecule');
                                                content = content.replace('</molecule>', '</molecule>\n</cml>');
                                            } else {
                                                alert('No molecule found in the cml file.');
                                                return;
                                            }
                                        }
                                        // only one molecule!!
                                        obj = ChemDoodle.readCML(content)[0];
                                        loadMolNoPBC(obj);
                                        alertMolecule();
                                        break;
                                    case 'chg':
                                        let nat = 0;
                                        let charges = [];
                                        content.split('\n').forEach(function (line) {
                                            if(line.trim().match(/^[a-zA-Z)]/)) {
                                                nat += 1;
                                                const s = line.trim().split(/\s+/);
                                                charges.push(parseFloat(s[s.length-1]));
                                            }
                                        });
                                        obj = ChemDoodle.readXYZ(ltrim(nat+"\nMOL\n"+content));
                                        // load atom charges
                                        for (let i = 0; i < nat; i++) {
                                            obj.atoms[i].charge = charges[i];
                                        }
                                        loadMolNoPBC(obj);
                                        alertMolecule();
                                        break;
                                    case 'tpr':
                                        readTpr(content).then(tpr => {
                                            return readXYZFast(tpr.names, tpr.positions, tpr.box, false)
                                                .then(mol => ({ mol, tpr })); 
                                        }).then(({ mol, tpr }) => {
                                            const cell = build_cell_from_gmxbox(mol, tpr.box);
                                            // load tpr bonds
                                            const bondorder = 1;
                                            tpr.bonds.forEach(b=> {
                                                mol.bonds.push(new ChemDoodle.structures.Bond(mol.atoms[b[0]], mol.atoms[b[1]], bondorder));
                                            });
                                            // load charges
                                            for (let i = 0; i < mol.atoms.length; i++) {
                                                mol.atoms[i].charge = tpr.charges[i];
                                            }
                                            loadMolPBC({ molecule: mol, unitCell: cell });
                                            alertMolecule();
                                        });
                                        break;
                                    case 'chk':
                                        readCHK(content).then(chk => { 
                                            if (chk.ispbc) {
                                                obj = ChemDoodle.readCIF(chk.cif, 1, 1, 1);
                                                loadMolPBC(obj);
                                            }
                                            else {
                                                obj = ChemDoodle.readXYZ(ltrim(chk.xyz));
                                                loadMolNoPBC(obj);
                                            }
                                            alertMolecule();
                                        });
                                        break;
                                    case 'gro':
                                        let n=0;
                                        content.split('\n').forEach(function (line, index) {
                                            if (index>=2 && /[a-zA-Z]/.test(line)) {
                                                names.push(fix_atomname(line.substring(10, 15)));
                                                let x = parseFloat(line.substring(20, 28).trim()) * 10.0;
                                                let y = parseFloat(line.substring(28, 36).trim()) * 10.0;
                                                let z = parseFloat(line.substring(36, 44).trim()) * 10.0;
                                                positions.push(x, y, z);
                                                n++;
                                            }
                                        });
                                        // get gro box: v1(x) v2(y) v3(z) v1(y)=0 v1(z)=0 v2(x) v2(z)=0 v3(x) v3(y)
                                        let box = content.split('\n')[n+2].trim().split(/\s+/).map(f=>parseFloat(f)*10.0);
                                        let hasbox = (box[0]>0 && box[1]>0 && box[2]>0);
                                        // 1D box
                                        b = zerobox;
                                        if (hasbox) {
                                            if (box.length==3) {
                                                b = [box[0], 0, 0, 0, box[1], 0, 0, 0, box[2]];
                                            } else if (box.length==9) {
                                                b = [box[0], 0, 0, box[5], box[1], 0, box[7], box[8], box[2]];
                                            } else {
                                                alert("Invalid gro box, should be 3 or 9 float numbers");
                                                return;
                                            }
                                        }
                                        readXYZFast(names, positions, b, true).then(mol=>{ 
                                            const cell = build_cell_from_gmxbox(mol, b);
                                            loadMolPBC({molecule:mol, unitCell:cell});
                                            alertMolecule();
                                        })
                                        break;
                                    default:
                                        alert('Unknown supported file format: ' + s);
                                        return;
                                }

                                // let rings = findRings(Mol.molecules[0])
                                // alert("total rings: " + rings.length)
                            };

                            if (s == 'tpr' || s == 'chk') {
                                // binary context
                                r.readAsArrayBuffer(a);
                            } else {
                                r.readAsText(a);
                            }
                        }
                        else {
                            alert("Failed to load file");
                        }
                    }

                    // import molecule from sketcher
                    async function molFromSketch() {
                        const b = $("import3d");
                        b.disabled = true; // 禁用按钮

                        try {
                            if (s = jme._getSmiles()) {
                                await molFromSmiles(s);
                            } else {
                                alert("错误! 画板中没有分子");
                            }
                        } catch (error) {
                            alert("导入3D分子失败: " + error);
                        } finally {
                            b.disabled = false; // 总是启用按钮
                        }
                    }

                    // generate 3D molecule from smiles
                    async function molFromSmiles(s) { 
                        Mol.stopAnimation(); //  停止动画
                        // try {
                        //     const url = "https://cactus.nci.nih.gov/chemical/structure/" + 
                        //                 s.replace(/#/g, "%23").replace(/\\/g, "%5C") + 
                        //                 "/file?format=mol&get3d=True";
                        //     const response = await fetch(url);
                        //     if (!response.ok) {
                        //         throw new Error('无法生成3D结构, 网络异常?');
                        //     }
                        //     const text = await response.text();
                        //     loadMolNoPBC(ChemDoodle.readMOL(text, 1));
                        //     $('inputsmiles').value = s;
                        // } catch (error) {
                        //     alert('无法生成3D结构: ' + error.message);
                        // }
                        // use rdkit is more good and faster
                        try {
                            let module = await RDKitModule();
                            let rdkit = new module.Smiles2Mol(s);
                            let text = rdkit.get_cml_content();
                            loadMolNoPBC(ChemDoodle.readCML(text)[0]);
                            // let text = rdkit.get_pdb_content();
                            // loadMolNoPBC(ChemDoodle.readPDB(text));
                            $('inputsmiles').value = s;
                        } catch (error) {
                            alert('无法通过RDKit对Smiles: "' + s + '" 生成3D结构');
                        }
                    }

                    // save mol2 file
                    function savefile() {
                        let mol = Mol.getMolecule();
                        if (mol) {
                            let context = "# Mol2 file generated by chemjs\n@<TRIPOS>MOLECULE\nMOL\n"+mol.atoms.length+
                                " "+mol.bonds.length+" "+" 0 0 0\nSMALL\nNO_CHARGES\n\n@<TRIPOS>ATOM\n";
                            let i = 1;
                            mol.atoms.forEach(function (atom) {
                                context += sprintf("%-5s %s %8.3f %8.3f %8.3f %5s\n", String(i), atom.label+(i<10000? i:'X'), atom.x, atom.y, atom.z, atom.label);
                                i++;
                            });
                            // bonds
                            context += "\n@<TRIPOS>BOND\n";
                            i=1;
                            mol.bonds.forEach(function (bond) {
                                let a1 = g_lab2ids.get(bond.a1.altLabel)+1;
                                let a2 = g_lab2ids.get(bond.a2.altLabel)+1;
                                let order = (bond.bondOrder==1.5? "ar" : String(bond.bondOrder)); // fix 1.5 
                                context += sprintf("%-5s %5s %5s %5s\n", String(i), String(a1), String(a2), order);
                                i++;
                            });
                            download(context, "mol.mol2");
                        }
                    }

                    // download context text to f file
                    function download(context, f) {
                        let h;
                        if ('function'==typeof window.Blob) {
                            h = new Blob([context], {type: "text/plain;charset=utf-8"});
                        } else {
                            let w = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
                            let d = new w; d.append(context);
                            h = d.getBlob("text/plain;charset=utf-8");
                        }
                        let c = window.URL || window.webkitURL, v = c.createObjectURL(h);
                        
                        let p = document.createElement("a");
                        if ('download' in p) {
                            p.style.visibility = "hidden";
                            p.href = v;
                            p.download = f;
                            document.body.appendChild(p);
                            let M = document.createEvent("MouseEvents");
                            M.initEvent("click", !0, !0);
                            p.dispatchEvent(M);
                            document.body.removeChild(p);
                        }
                        else {
                            // IE或者浏览器查看文本
                            navigator.msSaveBlob? navigator.msSaveBlob(h, f) : location.href = v;
                        }
                    }

                    // open file
                    window.File && window.FileReader && window.FileList && window.Blob ? $("loadfile").addEventListener('change', loadfile, !1): alert("The File APIs are not fully supported by your browser.")
                </script>

                <div>
                    <label for="label">Label</label>
                    <select id="label" onChange="setLabel(this.value)">
                      <option value="None" selected>None</option>
                      <option value="E">Element</option>
                      <option value="N">Serial</option>
                      <option value="Q">Charge</option>
                      <option value="E_N">Element+Serial</option>
                      <option value="E_Q">Element+Charge</option>
                    </select>
                    
                    <label for="styleform">Style</label>
                    <select id="styleform" onChange="setview(this.value)">
                      <option value="Line" selected>Line</option>
                      <option value="CPK">CPK</option>
                      <option value="vdW">vdW</option>
                      <option value="Stick">Stick</option>
                      <option value="Wireframe">Wireframe</option>
                    </select>
                </div>
            </td>

            <td style="display: none;">
                <div class="control-panel">

                    <!-- 弯曲方向 -->
                    <div class="control-row">
                        <label for="slider">弯曲方向:</label>
                        <input type="range" id="slider" min="-1" max="1" step="0.1" value="0">
                        <span id="slider_value">0.0</span>
                    </div>

                    <!-- 弯曲频率系数 -->
                    <div class="control-row">
                        <label for="factor">频率系数:</label>
                        <input type="number" id="factor" value="0.1" step="0.01" min="0">
                    </div>

                    <!-- 弯曲振幅系数 -->
                    <div class="control-row">
                        <label for="amplitude">振幅系数:</label>
                        <input type="number" id="amplitude" value="1" step="0.1">
                    </div>

                    <!-- 平面选择 -->
                    <div class="control-row">
                        <label>弯曲平面:</label>
                        <label><input type="radio" name="plane" value="XY" checked> XY</label>
                        <label><input type="radio" name="plane" value="XZ"> XZ</label>
                        <label><input type="radio" name="plane" value="YZ"> YZ</label>
                    </div>

                    <!-- 重置按钮 -->
                    <div class="control-row">
                        <button id="resetBtn">重置</button>
                    </div>

                </div>

                <style>
                    .control-panel {
                        display: flex;
                        flex-direction: column;
                        gap: 8px;
                        font-family: Arial, sans-serif;
                        font-size: 14px;
                        max-width: 250px;
                    }

                    .control-row {
                        display: flex;
                        align-items: center;
                        gap: 6px;
                    }

                    .control-row label {
                        min-width: 50px;
                    }

                    .control-row input[type="number"] {
                        width: 60px;
                        padding: 2px 4px;
                        box-sizing: border-box;
                    }

                    #slider {
                        flex: 1;
                    }

                    #slider_value {
                        width: 45px;
                        text-align: center;
                        display: inline-block;
                        font-family: monospace;
                    }

                    #resetBtn {
                        padding: 4px 10px;
                    }
                </style>

                <script>
                    const slider = $("slider");
                    const output = $("slider_value");
                    const factorInput = $("factor");
                    const amplitudeInput = $("amplitude");
                    const planeRadios = document.querySelectorAll('input[name="plane"]');
                    const resetBtn = $("resetBtn");

                    let center = null;

                    // 延迟初始化
                    function initMol() {
                        const mol = Mol.getMolecule();
                        g_basePositions = mol.atoms.map(atom => ({ x: atom.x, y: atom.y, z: atom.z }));
                        center = {
                            x: g_basePositions.reduce((s, a) => s + a.x, 0) / g_basePositions.length,
                            y: g_basePositions.reduce((s, a) => s + a.y, 0) / g_basePositions.length,
                            z: g_basePositions.reduce((s, a) => s + a.z, 0) / g_basePositions.length
                        };
                    }

                    function bendMolecule() {
                        Mol.stopAnimation();
                        const mol = Mol.getMolecule();

                        if (!g_basePositions) initMol();

                        const value = parseFloat(slider.value);
                        output.textContent = value.toFixed(2);

                        const factor = parseFloat(factorInput.value) || 0.1;
                        const amplitude = parseFloat(amplitudeInput.value) || 1;
                        const k = value * factor;
                        const direction = value >= 0 ? 1 : -1;

                        let plane = "XY";
                        planeRadios.forEach(r => { if (r.checked) plane = r.value; });

                        mol.atoms.forEach((atom, i) => {
                            const base = g_basePositions[i];
                            if (k === 0) {
                                atom.x = base.x; atom.y = base.y; atom.z = base.z;
                                return;
                            }
                            
                            const R = 1.0 / (Math.abs(k) + 1e-6);
                            let rel;

                            switch (plane) {
                                case "XY":
                                    rel = base.y - center.y; // 用Y做弯曲参数
                                    atom.x = base.x;
                                    atom.y = base.y;
                                    atom.z = base.z + direction * R * (1 - amplitude*Math.cos(rel * k));
                                    break;
                                case "XZ":
                                    rel = base.z - center.z; // 用Z做弯曲参数
                                    atom.x = base.x;
                                    atom.y = base.y + direction * R * (1 - amplitude*Math.cos(rel * k));
                                    atom.z = base.z;
                                    break;
                                case "YZ":
                                    rel = base.z - center.z; // 用Z做弯曲参数
                                    atom.x = base.x + direction * R * (1 - amplitude*Math.cos(rel * k));
                                    atom.y = base.y;
                                    atom.z = base.z;
                                    break;
                            }
                        });

                        Mol.repaint();
                    }

                    // 重置函数
                    function resetMolecule() {
                        if (!g_basePositions) return;
                        const mol = Mol.getMolecule();
                        mol.atoms.forEach((atom, i) => {
                            const base = g_basePositions[i];
                            atom.x = base.x; atom.y = base.y; atom.z = base.z;
                        });
                        Mol.repaint();

                        slider.value = 0;
                        output.textContent = "0.0";
                        factorInput.value = "0.1";
                        amplitudeInput.value = "1";
                        planeRadios[0].checked = true; // 默认XY
                    }

                    // 事件绑定
                    slider.oninput = bendMolecule;
                    factorInput.oninput = bendMolecule;
                    amplitudeInput.oninput = bendMolecule;
                    planeRadios.forEach(r => r.onchange = bendMolecule);
                    resetBtn.onclick = resetMolecule;
                </script>

            </td>
        </tr>
    </table>
    </div>
</html>
