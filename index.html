<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/liuyujie714/chemjs/js/pmd.min.css">
        <script src="https://cdn.jsdelivr.net/gh/liuyujie714/chemjs/js/cpp/libgmxtpr.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/liuyujie714/chemjs/js/cpp/libgauchk.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/liuyujie714/chemjs/js/cpp/libsimles2mol.js"></script>

        <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/liuyujie714/chemjs/js/ChemDoodleWeb.js"></script>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/liuyujie714/chemjs/js/uis/jquery-ui-1.10.3.custom.css" type="text/css">
        <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/liuyujie714/chemjs/js/uis/ChemDoodleWeb-uis.js"></script>

        <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/liuyujie714/chemjs/js/jsmol/JSmol.min.js"></script>
        <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/liuyujie714/chemjs/js/jsmol/JSmolJME.js"></script>
        <script type="text/javascript" language="javascript" src="https://cdn.jsdelivr.net/gh/liuyujie714/chemjs/js/jsmol/jsme/jsme/jsme.nocache.js"></script>
        <title>分子可视化</title>
    </head>
    
    <div class="wrap">
    <table>
        <tr>
            <td>
                <div style="display: flex;">
                    <input type="file" id="loadfile" value="读取文件" accept=".pdb, .mol, .cml, .chg, .xyz, .gro, .tpr, .chk" style="font-size:1em;font-weight:bold;color:red;width:200px; height:30px" />
                    <input type="text" id="inputsmiles" style="font-size:1em;font-weight:normal;color:black;width:200px; height:20px"/>
                </div>
                <script>
                    var $ = function(id) { return document.getElementById(id); }
                    
                    $("inputsmiles").addEventListener("keydown", function(e) {
                        if (e.keyCode == 13) {
                            e.preventDefault();
                            const value = this.value.trim();
                            if (value) {
                                molFromSmiles(value);
                            }
                        }
                    })
                </script>
            </td>
            <td>
                <div style="display: flex;">
                    <input type="button" id="import3d" onclick="molFromSketch()" value="=>从画板导入3D分子" style="font-size:1em;font-weight:bold;color:red;width:50%; height:30px;margin-right: 20px;" />
                    <input type="button" id="savefile" onclick="savefile()" value="导出3D分子" style="font-size:1em;font-weight:bold;color:red;width:50%; height:30px" />
                </div>
            </td>
        </tr>

        <tr>
            <td>
                <div id="jmediv" style="position:relative;width:400px;height:500px;"></div>
                <script>
                    // 创建一个分子画板
                    var jme = "jme";
                    let JMEInfo = {     
                        use: "HTML5",
                        divId: "jmediv", 
                        options : "autoez;nocanonize;",
                        editOptions: "editDisabled;",
                    };
                    Jmol.getJMEApplet("jme", JMEInfo);
                </script>
            </td>

            <td>
                <script>
                    // global atom altLabel(lab+serial) to index(0-based)
                    var g_lab2ids = new Map();

                    // add atom serial (1-based) from mol
                    function addAtomSerial(mol) {
                        g_lab2ids.clear()
                        for (let i = 0; i < mol.atoms.length; i++) {
                            let newlab = mol.atoms[i].label+String(i+1);
                            mol.atoms[i].altLabel = newlab;
                            g_lab2ids.set(newlab, i);
                        }
                    }

                    // add atom serial and loadMolecule (without pbc)
                    function loadMolNoPBC(mol) { 
                        addAtomSerial(mol)
                        Mol.loadMolecule(mol);
                    }

                    // 分子显示
                    var Mol = new ChemDoodle.EditorCanvas3D('Mol', 400, 400, {useServices:false, includeToolbar:true});
                    Mol.specs.backgroundColor='#000000';
                    Mol.specs.set3DRepresentation('Line');
                    Mol.specs.projectionPerspective_3D = true; // 透视投影
                    Mol.specs.compass_display=true; // 坐标轴显示
                    Mol.specs.atoms_displayLabels_3D=false; // 原子标签显示
                    Mol.specs.bonds_splitColor = true;
                    Mol.specs.text_font_stroke_3D = true;
                    //Mol.specs.bonds_cylinderDiameter_3D = 0.3; //键粗细
                    // 动画设置
                    Mol.handle = null;
                    Mol.timeout = 15;
                    Mol.startAnimation = ChemDoodle._AnimatorCanvas.prototype.startAnimation;
                    Mol.stopAnimation = ChemDoodle._AnimatorCanvas.prototype.stopAnimation;
                    Mol.isRunning = ChemDoodle._AnimatorCanvas.prototype.isRunning;
                    Mol.dblclick = ChemDoodle.RotatorCanvas.prototype.dblclick;
                    Mol.nextFrame = function(delta){
                        let matrix = [];
                        ChemDoodle.lib.mat4.identity(matrix);
                        let change = delta*Math.PI/15000;
                        ChemDoodle.lib.mat4.rotate(matrix, change, [ 1, 0, 0 ]);
                        ChemDoodle.lib.mat4.rotate(matrix, change, [ 0, 1, 0 ]);
                        ChemDoodle.lib.mat4.rotate(matrix, change, [ 0, 0, 1 ]);
                        ChemDoodle.lib.mat4.multiply(this.rotationMatrix, matrix)
                    };
                    ChemDoodle.io.file.content('https://cdn.jsdelivr.net/gh/liuyujie714/chemjs/mol/ch4.xyz', function(fileContent) {
                        let mol = ChemDoodle.readXYZ(ltrim(fileContent));
                        loadMolNoPBC(mol);
                    });
                    Mol.startAnimation(); // 开始动画

                    function alertMolecule() {
                        let message = 'This molecule contains ' + Mol.molecules[0].atoms.length + ' atoms and ' + Mol.molecules[0].bonds.length + ' bonds.';
                        alert(message);
                    }
        
                    function setview(id) {   
                        switch(id)
                        {
                            case 'Line':
                                Mol.specs.set3DRepresentation('Line');
                                break;
                            case 'Stick':
                                Mol.specs.set3DRepresentation('Stick');
                                break;
                            case 'Wireframe':
                                Mol.specs.set3DRepresentation('Wireframe');
                                break;
                            case 'vdW':
                                Mol.specs.set3DRepresentation('van der Waals Spheres');
                                break;
                            case 'CPK':
                                Mol.specs.set3DRepresentation('Ball and Stick');
                                break;
                        }
                        Mol.repaint();
                    }

                    // only work %s and %f
                    function sprintf() {
                        var a={s:function(a,b){return b*=1,m=Array(Math.max(Math.abs(b)-a.length+1,0)).join(" "),b>0?m+a:a+m},f:function(a,b){return b=b.split("."),a=parseFloat(a).toFixed(b[1]),m=Array(Math.max(Math.abs(b[0])-a.length+1,0)).join(" "),b[0]>0?m+a:a+m}},b=Array.prototype.slice.call(arguments).slice();return b.shift().toString().replace(/%(-*\d*\.*\d*)([sf])/g,function(c,d,e){if(!b.length)throw new Error("Too few elements");return a[e](b.shift(),d)})
                    }
        
                    function getcoords() {
                       // 第一个分子
                       let atoms = Mol.molecules[0].atoms;
                       let s = atoms.length+"\nMOL\n";
                       atoms.forEach(e => {
                            s += sprintf("%5s", e.label)+sprintf("%12.6f", e.x)+sprintf("%12.6f", e.y)+sprintf("%12.6f", e.z)+"\n";
                       });
                       $("textarea").value = s;
                    }

                    // remove multi started spaces and add '\n'
                    function ltrim(s) {
                        return s.split('\n').map(line=>line.trimStart()).join('\n');
                    }

                    function setcoords() {
                        try {
                            let xyz = ChemDoodle.readXYZ(ltrim($("textarea").value));
                            Mol.loadMolecule(xyz);
                        }
                        catch {
                            alert("坐标输入格式错误, 必须是XYZ");
                            return;
                        }
                    }

                    function showlabel() {
                        Mol.specs.atoms_displayLabels_3D=$("label").checked;
                        Mol.repaint();
                    }

                    // find 3-9 members rings from mol 
                    function findRings(mol) {
                        // fingerBreak = 5
                        return (new ChemDoodle.informatics.EulerFacetRingFinder(mol)).rings
                    }

                    function extension(t) {return t.substring(t.lastIndexOf(".")+1).toLowerCase()}

                    function triclinicToABC(lx, ly, lz, xy, xz, yz) {
                        const a = [lx, 0, 0];
                        const b = [xy, ly, 0];
                        const c = [xz, yz, lz];

                        const norm = v => Math.sqrt(v[0]**2 + v[1]**2 + v[2]**2);
                        const dot = (u, v) => u[0]*v[0] + u[1]*v[1] + u[2]*v[2];

                        const na = norm(a);
                        const nb = norm(b);
                        const nc = norm(c);

                        const alpha = Math.acos(dot(b, c) / (nb * nc)) * 180 / Math.PI;
                        const beta  = Math.acos(dot(a, c) / (na * nc)) * 180 / Math.PI;
                        const gamma = Math.acos(dot(a, b) / (na * nb)) * 180 / Math.PI;

                        return { a: na, b: nb, c: nc, alpha, beta, gamma };
                    }

                    // convert cartesian to fractional
                    function fracCoords(x, y, z, a_vec, b_vec, c_vec) {
                        let M = [
                            [a_vec[0], b_vec[0], c_vec[0]],
                            [a_vec[1], b_vec[1], c_vec[1]],
                            [a_vec[2], b_vec[2], c_vec[2]]
                        ];

                        // 求逆
                        let det = M[0][0]*(M[1][1]*M[2][2]-M[1][2]*M[2][1])
                                - M[0][1]*(M[1][0]*M[2][2]-M[1][2]*M[2][0])
                                + M[0][2]*(M[1][0]*M[2][1]-M[1][1]*M[2][0]);

                        let inv = [
                            [
                            (M[1][1]*M[2][2]-M[1][2]*M[2][1])/det,
                            (M[0][2]*M[2][1]-M[0][1]*M[2][2])/det,
                            (M[0][1]*M[1][2]-M[0][2]*M[1][1])/det
                            ],
                            [
                            (M[1][2]*M[2][0]-M[1][0]*M[2][2])/det,
                            (M[0][0]*M[2][2]-M[0][2]*M[2][0])/det,
                            (M[0][2]*M[1][0]-M[0][0]*M[1][2])/det
                            ],
                            [
                            (M[1][0]*M[2][1]-M[1][1]*M[2][0])/det,
                            (M[0][1]*M[2][0]-M[0][0]*M[2][1])/det,
                            (M[0][0]*M[1][1]-M[0][1]*M[1][0])/det
                            ]
                        ];

                        // 乘以逆矩阵
                        let fx = inv[0][0]*x + inv[0][1]*y + inv[0][2]*z;
                        let fy = inv[1][0]*x + inv[1][1]*y + inv[1][2]*z;
                        let fz = inv[2][0]*x + inv[2][1]*y + inv[2][2]*z;

                        return [fx, fy, fz];
                    }

                    // 没有任何对称操作，只能针对有晶胞信息的体系，没有盒子大小的体系不可用cif
                    function cif_header(n, crystal) {
                        return "data_MOL\n" + "__chemical_name_mineral " + n + 
                        "\n_cell_length_a " + crystal.a + "\n_cell_length_b " +  crystal.b + "\n_cell_length_c " + crystal.c + 
                        "\n_cell_angle_alpha " + crystal.alpha +
                        "\n_cell_angle_beta " + crystal.beta + 
                        "\n_cell_angle_gamma " + crystal.gamma + 
                        "\n_symmetry_space_group_name_H-M 'P 1'" + "\nloop_\n_space_group_symop_operation_xyz\n'x, y, z'" +
                        "\nloop_\n_atom_site_label\n_atom_site_type_symbol\n_atom_site_fract_x\n_atom_site_fract_y\n_atom_site_fract_z\n";
                    }

                    // convert gromacs tpr binary stream to cif & xyz text
                    async function readTpr(arrbuffer) {
                        let filename = "___temp.tpr";
                        let module = await TprModule();
                        let uint8View = new Uint8Array(arrbuffer);
                        module.FS.writeFile(filename, uint8View);
                        let tpr = new module.TprReader(filename, false, false, false);
                        let c = tpr.get_xvf("x"); // nm
                        let name = tpr.get_name('atom'); // atomname
                        let box =  tpr.get_xvf("box");
                        tpr.delete();
                        module.FS.unlink(filename);
                        let ux = box.get(0)*10.0;
                        let uy = box.get(4)*10.0;
                        let uz = box.get(8)*10.0;
                        let xy = box.get(3)*10.0;
                        let xz = box.get(6)*10.0;
                        let yz = box.get(7)*10.0;
                        let natoms = c.size()/3;
                        let cif = "";
                        let xyz = "";
                        let ispbc = (ux>0 && uy>0 && uz>0);
                        if (ispbc) {
                            let crystal = triclinicToABC(ux, uy, uz, xy, xz, yz);
                            cif = cif_header(natoms, crystal);
                            let a_vec = [ux, 0, 0];
                            let b_vec = [xy, uy, 0];
                            let c_vec = [xz, yz, uz];
                            for (let i = 0; i < natoms; i++) {
                                let x = c.get(3*i) * 10.0;
                                let y = c.get(3*i+1) * 10.0;
                                let z = c.get(3*i+2) * 10.0;
                                let [fx, fy, fz] = fracCoords(x, y, z, a_vec, b_vec, c_vec);
                                // Here only use the first char to represent element!!!
                                cif += sprintf("MOL %s %8.3f %8.3f %8.3f\n", name.get(i)[0], fx, fy, fz);
                            }
                        } 
                        else {
                            xyz += natoms + "\nMOL\n";
                            for (let i = 0; i < natoms; i++) {
                                let x = c.get(3*i) * 10.0;
                                let y = c.get(3*i+1) * 10.0;
                                let z = c.get(3*i+2) * 10.0;
                                xyz += sprintf("%s %8.3f %8.3f %8.3f\n", name.get(i)[0], x, y, z);
                            }
                        }
                        return {cif:cif, xyz:xyz, ispbc:ispbc};
                    }

                    // convert gaussian binary chk file to cif & xyz text
                    async function readCHK(arrbuffer) {
                        let filename = "___temp.chk";
                        let module = await ChkModule();
                        let uint8View = new Uint8Array(arrbuffer);
                        module.FS.writeFile(filename, uint8View);
                        let chk = new module.GauChkParserWarpper(filename);
                        let name = chk.get_name(); // element names
                        let c = chk.get_coords(); // coorrds, 3*natoms
                        chk.delete();
                        module.FS.unlink(filename);
                        let natoms = c.size()/3;
                        // TODO: get unit cell
                        let ispbc = false; 
                        let cif = "";
                        let xyz = "";
                        if (ispbc) {
                            // TODO
                            let ux = 1, uy = 1, uz = 1, xy = 0, xz = 0, yz = 0;
                            let crystal = triclinicToABC(ux, uy, uz, xy, xz, yz);
                            cif = cif_header(natoms, crystal);
                            let a_vec = [ux, 0, 0];
                            let b_vec = [xy, uy, 0];
                            let c_vec = [xz, yz, uz];
                            for (let i = 0; i < natoms; i++) {
                                let x = c.get(3*i);
                                let y = c.get(3*i+1);
                                let z = c.get(3*i+2);
                                let [fx, fy, fz] = fracCoords(x, y, z, a_vec, b_vec, c_vec);
                                cif += sprintf("MOL %s %8.3f %8.3f %8.3f\n", name.get(i), fx, fy, fz);
                            }
                        } 
                        else {
                            xyz += natoms + "\nMOL\n";
                            for (let i = 0; i < natoms; i++) {
                                let x = c.get(3*i);
                                let y = c.get(3*i+1);
                                let z = c.get(3*i+2);
                                xyz += sprintf("%s %8.3f %8.3f %8.3f\n", name.get(i), x, y, z);
                            }
                        }
                        return {cif:cif, xyz:xyz, ispbc:ispbc};
                    }

                    function get_com(mol) {
                        let com = [0,0,0];
                        mol.atoms.forEach(function (atom) {
                            com[0] += atom.x;
                            com[1] += atom.y;
                            com[2] += atom.z;
                        });
                        com[0] /= mol.atoms.length;
                        com[1] /= mol.atoms.length;
                        com[2] /= mol.atoms.length;
                        return com;
                    }

                    function loadfile(t) {
                        let a=t.target.files[0];
                        if(a) {
                            // 停止动画
                            Mol.stopAnimation();

                            let r=new FileReader;
                            let s = extension(a.name);

                            r.onload=function(t) {
                                content=t.target.result;
                                let obj;
                                switch(s)
                                {
                                    case 'pdb':
                                        obj = ChemDoodle.readPDB(content);
                                        loadMolNoPBC(obj);
                                        alertMolecule();
                                        break;
                                    case 'xyz':
                                        obj = ChemDoodle.readXYZ(ltrim(content));
                                        loadMolNoPBC(obj);
                                        alertMolecule();
                                        break;
                                    case 'mol':
                                        obj = ChemDoodle.readMOL(content, 1);
                                        loadMolNoPBC(obj);
                                        alertMolecule();
                                        break;
                                    case 'cml':
                                        // only one molecule!!
                                        obj = ChemDoodle.readCML(content)[0];
                                        loadMolNoPBC(obj);
                                        alertMolecule();
                                        break;
                                    case 'chg':
                                        let nat = 0;
                                        content.split('\n').forEach(function (line) {
                                            if(line.match(/^[a-zA-Z)]/)) {nat += 1;}
                                        });
                                        obj = ChemDoodle.readXYZ(ltrim(nat+"\nMOL\n"+content));
                                        loadMolNoPBC(obj);
                                        alertMolecule();
                                        break;
                                    case 'tpr':
                                        readTpr(content).then(tpr => { 
                                            if (tpr.ispbc) {
                                                obj = ChemDoodle.readCIF(tpr.cif, 1, 1, 1);
                                                addAtomSerial(obj.molecule);
                                                Mol.loadContent([obj.molecule], [obj.unitCell]);
                                            }
                                            else {
                                                obj = ChemDoodle.readXYZ(ltrim(tpr.xyz));
                                                loadMolNoPBC(obj);
                                            }
                                            alertMolecule();
                                        });
                                        break;
                                    case 'chk':
                                        readCHK(content).then(chk => { 
                                            if (chk.ispbc) {
                                                obj = ChemDoodle.readCIF(chk.cif, 1, 1, 1);
                                                addAtomSerial(obj.molecule);
                                                Mol.loadContent([obj.molecule], [obj.unitCell]);
                                            }
                                            else {
                                                obj = ChemDoodle.readXYZ(ltrim(chk.xyz));
                                                loadMolNoPBC(obj);
                                            }
                                            alertMolecule();
                                        });
                                        break;
                                    case 'gro':
                                        let n=0;
                                        let coords = [], atoms = [];
                                        content.split('\n').forEach(function (line, index) {
                                            if (index>=2 && /[a-zA-Z]/.test(line)) {
                                                let atom = line.substring(10, 15).trim().replace(/\d/g, '');
                                                // process HW or OW
                                                if (atom.substring(0, 2).toUpperCase()=='HW' || atom.substring(0, 2).toUpperCase()=='OW') {
                                                    atom = atom[0];
                                                }
                                                atoms.push(atom);

                                                let x = parseFloat(line.substring(20, 28).trim()) * 10.0;
                                                let y = parseFloat(line.substring(28, 36).trim()) * 10.0;
                                                let z = parseFloat(line.substring(36, 44).trim()) * 10.0;
                                                coords.push([x, y, z]);
                                                n++;
                                            }
                                        });
                                        // get gro box: v1(x) v2(y) v3(z) v1(y)=0 v1(z)=0 v2(x) v2(z)=0 v3(x) v3(y)
                                        let box = content.split('\n')[n+2].trim().split(/\s+/).map(f=>parseFloat(f)*10.0);
                                        let hasbox = (box[0]>0 && box[1]>0 && box[2]>0);
                                        // load gro to scene
                                        if (hasbox) {
                                            let crystal;
                                            let a_vec, b_vec, c_vec;
                                            if (box.length==3) {
                                                crystal = triclinicToABC(box[0], box[1], box[2], 0, 0, 0);
                                                a_vec = [box[0], 0, 0];
                                                b_vec = [0, box[1], 0];
                                                c_vec = [0, 0, box[2]];
                                            } else if (box.length==9) {
                                                crystal = triclinicToABC(box[0], box[1], box[2], box[5], box[7], box[8]);
                                                a_vec = [box[0], 0, 0];
                                                b_vec = [box[5], box[1], 0];
                                                c_vec = [box[7], box[8], box[2]];
                                            } else {
                                                alert("Invalid gro box, should be 3 or 9 float numbers");
                                                return;
                                            }
                                            let text = cif_header(coords.length, crystal);
                                            coords.forEach(function (c, index) {
                                                let [fx, fy, fz] = fracCoords(c[0], c[1], c[2], a_vec, b_vec, c_vec);
                                                text += "MOL " + atoms[index] + ' ' + fx + ' ' + fy + ' ' + fz + '\n';
                                            });
                                            obj = ChemDoodle.readCIF(text, 1, 1, 1);
                                            addAtomSerial(obj.molecule); // must do it
                                            Mol.loadContent([obj.molecule], [obj.unitCell]);
                                        } else {
                                            let text = coords.length + "\nMOL\n";
                                            coords.forEach(function (c, index) {
                                                text += atoms[index] + ' ' + c[0] + ' ' + c[1] + ' ' + c[2] + '\n';
                                            });
                                            loadMolNoPBC(ChemDoodle.readXYZ(ltrim(text)));
                                        }
                                        alertMolecule();
                                        break;
                                    default:
                                        alert('Unknown supported file format: ' + s);
                                        return;
                                }

                                // let rings = findRings(Mol.molecules[0])
                                // alert("total rings: " + rings.length)
                            };

                            if (s == 'tpr' || s == 'chk') {
                                // binary context
                                r.readAsArrayBuffer(a);
                            } else {
                                r.readAsText(a);
                            }
                        }
                        else alert("Failed to load file")
                    }

                    // import molecule from sketcher
                    async function molFromSketch() {
                        const b = $("import3d");
                        b.disabled = true; // 禁用按钮

                        try {
                            if (s = jme._getSmiles()) {
                                await molFromSmiles(s);
                            } else {
                                alert("错误! 画板中没有分子");
                            }
                        } catch (error) {
                            alert("导入3D分子失败: " + error);
                        } finally {
                            b.disabled = false; // 总是启用按钮
                        }
                    }

                    // generate 3D molecule from smiles
                    async function molFromSmiles(s) { 
                        Mol.stopAnimation(); //  停止动画
                        // try {
                        //     const url = "https://cactus.nci.nih.gov/chemical/structure/" + 
                        //                 s.replace(/#/g, "%23").replace(/\\/g, "%5C") + 
                        //                 "/file?format=mol&get3d=True";
                        //     const response = await fetch(url);
                        //     if (!response.ok) {
                        //         throw new Error('无法生成3D结构, 网络异常?');
                        //     }
                        //     const text = await response.text();
                        //     loadMolNoPBC(ChemDoodle.readMOL(text, 1));
                        // } catch (error) {
                        //     alert('无法生成3D结构: ' + error.message);
                        // }
                        // use rdkit is more good and faster
                        try {
                            let module = await RDKitModule();
                            let rdkit = new module.Smiles2Mol(s);
                            let text = rdkit.get_cml_content();
                            loadMolNoPBC(ChemDoodle.readCML(text)[0]);
                            // let text = rdkit.get_pdb_content();
                            // loadMolNoPBC(ChemDoodle.readPDB(text));
                            $('inputsmiles').value = s;
                        } catch (error) {
                            alert('无法通过RDkit对Smiles: "' + s + '" 生成3D结构');
                        }
                    }

                    // save mol2 file
                    function savefile() {
                        let mol = Mol.getMolecule();
                        if (mol) {
                            let context = "# Mol2 file generated by chemjs\n@<TRIPOS>MOLECULE\nMOL\n"+mol.atoms.length+
                                " "+mol.bonds.length+" "+" 0 0 0\nSMALL\nNO_CHARGES\n\n@<TRIPOS>ATOM\n";
                            let i = 1;
                            mol.atoms.forEach(function (atom) {
                                context += sprintf("%-5s %s %8.3f %8.3f %8.3f %5s\n", String(i), atom.label+(i<10000? i:'X'), atom.x, atom.y, atom.z, atom.label);
                                i++;
                            });
                            // bonds
                            context += "\n@<TRIPOS>BOND\n";
                            i=1;
                            mol.bonds.forEach(function (bond) {
                                let a1 = g_lab2ids.get(bond.a1.altLabel)+1;
                                let a2 = g_lab2ids.get(bond.a2.altLabel)+1;
                                let order = (bond.bondOrder==1.5? "ar" : String(bond.bondOrder)); // fix 1.5 
                                context += sprintf("%-5s %5s %5s %5s\n", String(i), String(a1), String(a2), order);
                                i++;
                            });
                            download(context, "mol.mol2");
                        }
                    }

                    // download context text to f file
                    function download(context, f) {
                        let h;
                        if ('function'==typeof window.Blob) {
                            h = new Blob([context], {type: "text/plain;charset=utf-8"});
                        } else {
                            let w = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
                            let d = new w; d.append(context);
                            h = d.getBlob("text/plain;charset=utf-8");
                        }
                        let c = window.URL || window.webkitURL, v = c.createObjectURL(h);
                        
                        let p = document.createElement("a");
                        if ('download' in p) {
                            p.style.visibility = "hidden";
                            p.href = v;
                            p.download = f;
                            document.body.appendChild(p);
                            let M = document.createEvent("MouseEvents");
                            M.initEvent("click", !0, !0);
                            p.dispatchEvent(M);
                            document.body.removeChild(p);
                        }
                        else {
                            // IE或者浏览器查看文本
                            navigator.msSaveBlob? navigator.msSaveBlob(h, f) : location.href = v;
                        }
                    }

                    // open file
                    window.File && window.FileReader && window.FileList && window.Blob ? $("loadfile").addEventListener('change', loadfile, !1): alert("The File APIs are not fully supported by your browser.")
                </script>

                <div> 
                    <input type="checkbox" id="label" onChange="showlabel()" /> Label
                    <input type="radio" name="style" id='Line' checked="checked" onChange="setview(id)" /> Line
                    <input type="radio" name="style" id='CPK'  onChange="setview(id)" /> CPK
                    <input type="radio" name="style" id='vdW' onChange="setview(id)" /> vdW
                    <input type="radio" name="style" id='Stick' onChange="setview(id)" /> Stick
                    <input type="radio" name="style" id='Wireframe' onChange="setview(id)" /> Wire
                </div>

            </td>
        </tr>

    </table>
    </div>
    
</html>

